// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_Main
#include <Main.h>
#endif
#ifndef INCLUDED_Reflect
#include <Reflect.h>
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_haxegon_Scene
#include <haxegon/Scene.h>
#endif
#ifndef INCLUDED_openfl_errors_ArgumentError
#include <openfl/errors/ArgumentError.h>
#endif
#ifndef INCLUDED_openfl_errors_Error
#include <openfl/errors/Error.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_bacb93e0147ccff0_6_init,"haxegon.Scene","init",0xb6162260,"haxegon.Scene.init","haxegon/Scene.hx",6,0x6f0d3761)
HX_LOCAL_STACK_FRAME(_hx_pos_bacb93e0147ccff0_24_restart,"haxegon.Scene","restart",0x13b6527f,"haxegon.Scene.restart","haxegon/Scene.hx",24,0x6f0d3761)
HX_LOCAL_STACK_FRAME(_hx_pos_bacb93e0147ccff0_42_checkforrenderfunction,"haxegon.Scene","checkforrenderfunction",0x233502bf,"haxegon.Scene.checkforrenderfunction","haxegon/Scene.hx",42,0x6f0d3761)
HX_LOCAL_STACK_FRAME(_hx_pos_bacb93e0147ccff0_53_update,"haxegon.Scene","update",0xf164e159,"haxegon.Scene.update","haxegon/Scene.hx",53,0x6f0d3761)
HX_LOCAL_STACK_FRAME(_hx_pos_bacb93e0147ccff0_57_render,"haxegon.Scene","render",0x6f88c6a6,"haxegon.Scene.render","haxegon/Scene.hx",57,0x6f0d3761)
HX_LOCAL_STACK_FRAME(_hx_pos_bacb93e0147ccff0_60_callscenemethod,"haxegon.Scene","callscenemethod",0x6b8a1bff,"haxegon.Scene.callscenemethod","haxegon/Scene.hx",60,0x6f0d3761)
HX_LOCAL_STACK_FRAME(_hx_pos_bacb93e0147ccff0_85_findscene,"haxegon.Scene","findscene",0x4ae83123,"haxegon.Scene.findscene","haxegon/Scene.hx",85,0x6f0d3761)
HX_LOCAL_STACK_FRAME(_hx_pos_bacb93e0147ccff0_105_change,"haxegon.Scene","change",0x21d1ecc0,"haxegon.Scene.change","haxegon/Scene.hx",105,0x6f0d3761)
HX_LOCAL_STACK_FRAME(_hx_pos_bacb93e0147ccff0_119_get,"haxegon.Scene","get",0xfc37f346,"haxegon.Scene.get","haxegon/Scene.hx",119,0x6f0d3761)
HX_LOCAL_STACK_FRAME(_hx_pos_bacb93e0147ccff0_123_getcurrentsceneclass,"haxegon.Scene","getcurrentsceneclass",0xa7d1e6df,"haxegon.Scene.getcurrentsceneclass","haxegon/Scene.hx",123,0x6f0d3761)
namespace haxegon{

void Scene_obj::__construct() { }

Dynamic Scene_obj::__CreateEmpty() { return new Scene_obj; }

void *Scene_obj::_hx_vtable = 0;

Dynamic Scene_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Scene_obj > _hx_result = new Scene_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Scene_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x3eb4098c;
}

void Scene_obj::init(){
            	HX_STACKFRAME(&_hx_pos_bacb93e0147ccff0_6_init)
HXLINE(   7)		::haxegon::Scene_obj::scenelist = ::cpp::VirtualArray_obj::__new(0);
HXLINE(   8)		::haxegon::Scene_obj::currentscene = (int)0;
HXLINE(  10)		 ::Dynamic maininstance = null();
HXLINE(  12)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE(  13)			maininstance = ::Type_obj::createInstance(hx::ClassOf< ::Main >(),::cpp::VirtualArray_obj::__new(0));
            		}
            		catch( ::Dynamic _hx_e){
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic e = _hx_e;
HXLINE(  15)				maininstance = ::Type_obj::createEmptyInstance(hx::ClassOf< ::Main >());
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXLINE(  18)		::haxegon::Scene_obj::scenelist->push(maininstance);
HXLINE(  19)		::haxegon::Scene_obj::callscenemethod(::haxegon::Scene_obj::scenelist->__get(::haxegon::Scene_obj::currentscene),HX_("init",10,3b,bb,45));
HXLINE(  21)		::haxegon::Scene_obj::checkforrenderfunction();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Scene_obj,init,(void))

void Scene_obj::restart(hx::Class scenetorestart){
            	HX_STACKFRAME(&_hx_pos_bacb93e0147ccff0_24_restart)
HXLINE(  25)		int sceneid = (int)-1;
HXLINE(  26)		{
HXLINE(  26)			int _g1 = (int)0;
HXDLIN(  26)			int _g = ::haxegon::Scene_obj::scenelist->get_length();
HXDLIN(  26)			while((_g1 < _g)){
HXLINE(  26)				_g1 = (_g1 + (int)1);
HXDLIN(  26)				int i = (_g1 - (int)1);
HXLINE(  27)				if (hx::IsEq( scenetorestart,::Type_obj::getClass(::haxegon::Scene_obj::scenelist->__get(i)) )) {
HXLINE(  28)					sceneid = i;
HXLINE(  29)					goto _hx_goto_1;
            				}
            			}
            			_hx_goto_1:;
            		}
HXLINE(  33)		if ((sceneid != (int)-1)) {
HXLINE(  37)			::cpp::VirtualArray _hx_tmp = ::haxegon::Scene_obj::scenelist;
HXDLIN(  37)			_hx_tmp->set(sceneid,::Type_obj::createInstance(scenetorestart,::cpp::VirtualArray_obj::__new(0)));
HXLINE(  38)			::haxegon::Scene_obj::callscenemethod(::haxegon::Scene_obj::scenelist->__get(::haxegon::Scene_obj::currentscene),HX_("init",10,3b,bb,45));
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Scene_obj,restart,(void))

void Scene_obj::checkforrenderfunction(){
            	HX_STACKFRAME(&_hx_pos_bacb93e0147ccff0_42_checkforrenderfunction)
HXLINE(  45)		::haxegon::Scene_obj::hasseperaterenderfunction = hx::IsNotNull( ::Reflect_obj::field(::haxegon::Scene_obj::scenelist->__get(::haxegon::Scene_obj::currentscene),HX_("render",56,6b,29,05)) );
HXLINE(  46)		if (!(::haxegon::Scene_obj::hasseperaterenderfunction)) {
HXLINE(  48)			::haxegon::Scene_obj::hasseperaterenderfunction = hx::IsNotNull( ::Reflect_obj::field(::Type_obj::getClass(::haxegon::Scene_obj::scenelist->__get(::haxegon::Scene_obj::currentscene)),HX_("render",56,6b,29,05)) );
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Scene_obj,checkforrenderfunction,(void))

void Scene_obj::update(){
            	HX_STACKFRAME(&_hx_pos_bacb93e0147ccff0_53_update)
HXDLIN(  53)		::haxegon::Scene_obj::callscenemethod(::haxegon::Scene_obj::scenelist->__get(::haxegon::Scene_obj::currentscene),HX_("update",09,86,05,87));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Scene_obj,update,(void))

void Scene_obj::render(){
            	HX_STACKFRAME(&_hx_pos_bacb93e0147ccff0_57_render)
HXDLIN(  57)		::haxegon::Scene_obj::callscenemethod(::haxegon::Scene_obj::scenelist->__get(::haxegon::Scene_obj::currentscene),HX_("render",56,6b,29,05));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Scene_obj,render,(void))

void Scene_obj::callscenemethod( ::Dynamic scene,::String method){
            	HX_STACKFRAME(&_hx_pos_bacb93e0147ccff0_60_callscenemethod)
HXLINE(  61)		 ::Dynamic instanceFunc = ::Reflect_obj::field(::haxegon::Scene_obj::scenelist->__get(::haxegon::Scene_obj::currentscene),method);
HXLINE(  62)		bool _hx_tmp;
HXDLIN(  62)		if (hx::IsNotNull( instanceFunc )) {
HXLINE(  62)			_hx_tmp = ::Reflect_obj::isFunction(instanceFunc);
            		}
            		else {
HXLINE(  62)			_hx_tmp = false;
            		}
HXDLIN(  62)		if (_hx_tmp) {
HXLINE(  63)			try {
            				HX_STACK_CATCHABLE( ::openfl::errors::ArgumentError, 0);
HXLINE(  64)				::Reflect_obj::callMethod(::haxegon::Scene_obj::scenelist->__get(::haxegon::Scene_obj::currentscene),instanceFunc,::cpp::VirtualArray_obj::__new(0));
            			}
            			catch( ::Dynamic _hx_e){
            				if (_hx_e.IsClass<  ::openfl::errors::ArgumentError >() ){
            					HX_STACK_BEGIN_CATCH
            					 ::openfl::errors::ArgumentError e = _hx_e;
HXLINE(  66)					HX_STACK_DO_THROW(((((HX_("ERROR: Couldn't call ",0a,d4,d4,24) + ::Type_obj::getClassName(scene)) + HX_(".",2e,00,00,00)) + method) + HX_("() without any arguments.",e3,b4,4b,0d)));
            				}
            				else {
            					HX_STACK_DO_THROW(_hx_e);
            				}
            			}
HXLINE(  68)			return;
            		}
HXLINE(  72)		 ::Dynamic classFunc = ::Reflect_obj::field(::Type_obj::getClass(::haxegon::Scene_obj::scenelist->__get(::haxegon::Scene_obj::currentscene)),method);
HXLINE(  73)		bool _hx_tmp1;
HXDLIN(  73)		if (hx::IsNotNull( classFunc )) {
HXLINE(  73)			_hx_tmp1 = ::Reflect_obj::isFunction(classFunc);
            		}
            		else {
HXLINE(  73)			_hx_tmp1 = false;
            		}
HXDLIN(  73)		if (_hx_tmp1) {
HXLINE(  74)			try {
            				HX_STACK_CATCHABLE( ::openfl::errors::ArgumentError, 0);
HXLINE(  75)				::Reflect_obj::callMethod(::haxegon::Scene_obj::scenelist->__get(::haxegon::Scene_obj::currentscene),classFunc,::cpp::VirtualArray_obj::__new(0));
            			}
            			catch( ::Dynamic _hx_e){
            				if (_hx_e.IsClass<  ::openfl::errors::ArgumentError >() ){
            					HX_STACK_BEGIN_CATCH
            					 ::openfl::errors::ArgumentError e1 = _hx_e;
HXLINE(  77)					HX_STACK_DO_THROW(((((HX_("ERROR: Couldn't call ",0a,d4,d4,24) + ::Type_obj::getClassName(scene)) + HX_(".",2e,00,00,00)) + method) + HX_("() without any arguments.",e3,b4,4b,0d)));
            				}
            				else {
            					HX_STACK_DO_THROW(_hx_e);
            				}
            			}
HXLINE(  79)			return;
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Scene_obj,callscenemethod,(void))

int Scene_obj::findscene(hx::Class findscene){
            	HX_STACKFRAME(&_hx_pos_bacb93e0147ccff0_85_findscene)
HXLINE(  86)		{
HXLINE(  86)			int _g1 = (int)0;
HXDLIN(  86)			int _g = ::haxegon::Scene_obj::scenelist->get_length();
HXDLIN(  86)			while((_g1 < _g)){
HXLINE(  86)				_g1 = (_g1 + (int)1);
HXDLIN(  86)				int i = (_g1 - (int)1);
HXLINE(  87)				if (hx::IsEq( findscene,::Type_obj::getClass(::haxegon::Scene_obj::scenelist->__get(i)) )) {
HXLINE(  88)					return i;
            				}
            			}
            		}
HXLINE(  92)		 ::Dynamic newscene = null();
HXLINE(  94)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE(  95)			newscene = ::Type_obj::createInstance(findscene,::cpp::VirtualArray_obj::__new(0));
            		}
            		catch( ::Dynamic _hx_e){
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic e = _hx_e;
HXLINE(  97)				newscene = ::Type_obj::createEmptyInstance(findscene);
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXLINE( 100)		::haxegon::Scene_obj::scenelist->push(newscene);
HXLINE( 102)		return (::haxegon::Scene_obj::scenelist->get_length() - (int)1);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Scene_obj,findscene,return )

 ::Dynamic Scene_obj::change(hx::Class newscene){
            	HX_STACKFRAME(&_hx_pos_bacb93e0147ccff0_105_change)
HXLINE( 106)		::haxegon::Scene_obj::currentscene = ::haxegon::Scene_obj::findscene(newscene);
HXLINE( 107)		int _hx_tmp = ::haxegon::Scene_obj::currentscene;
HXDLIN( 107)		if ((_hx_tmp == (::haxegon::Scene_obj::scenelist->get_length() - (int)1))) {
HXLINE( 108)			::haxegon::Scene_obj::callscenemethod(::haxegon::Scene_obj::scenelist->__get(::haxegon::Scene_obj::currentscene),HX_("init",10,3b,bb,45));
            		}
            		else {
HXLINE( 110)			::haxegon::Scene_obj::callscenemethod(::haxegon::Scene_obj::scenelist->__get(::haxegon::Scene_obj::currentscene),HX_("reset",cf,49,c8,e6));
            		}
HXLINE( 113)		::haxegon::Scene_obj::checkforrenderfunction();
HXLINE( 115)		return ::haxegon::Scene_obj::scenelist->__get(::haxegon::Scene_obj::currentscene);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Scene_obj,change,return )

 ::Dynamic Scene_obj::get(hx::Class requiredscene){
            	HX_STACKFRAME(&_hx_pos_bacb93e0147ccff0_119_get)
HXDLIN( 119)		::cpp::VirtualArray _hx_tmp = ::haxegon::Scene_obj::scenelist;
HXDLIN( 119)		return _hx_tmp->__get(::haxegon::Scene_obj::findscene(requiredscene));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Scene_obj,get,return )

 ::Dynamic Scene_obj::getcurrentsceneclass(){
            	HX_STACKFRAME(&_hx_pos_bacb93e0147ccff0_123_getcurrentsceneclass)
HXDLIN( 123)		return ::haxegon::Scene_obj::scenelist->__get(::haxegon::Scene_obj::currentscene);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Scene_obj,getcurrentsceneclass,return )

::cpp::VirtualArray Scene_obj::scenelist;

int Scene_obj::currentscene;

bool Scene_obj::hasseperaterenderfunction;


Scene_obj::Scene_obj()
{
}

bool Scene_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"get") ) { outValue = get_dyn(); return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"init") ) { outValue = init_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"update") ) { outValue = update_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"render") ) { outValue = render_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"change") ) { outValue = change_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"restart") ) { outValue = restart_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"findscene") ) { outValue = findscene_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"scenelist") ) { outValue = ( scenelist ); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"currentscene") ) { outValue = ( currentscene ); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"callscenemethod") ) { outValue = callscenemethod_dyn(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"getcurrentsceneclass") ) { outValue = getcurrentsceneclass_dyn(); return true; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"checkforrenderfunction") ) { outValue = checkforrenderfunction_dyn(); return true; }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"hasseperaterenderfunction") ) { outValue = ( hasseperaterenderfunction ); return true; }
	}
	return false;
}

bool Scene_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"scenelist") ) { scenelist=ioValue.Cast< ::cpp::VirtualArray >(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"currentscene") ) { currentscene=ioValue.Cast< int >(); return true; }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"hasseperaterenderfunction") ) { hasseperaterenderfunction=ioValue.Cast< bool >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *Scene_obj_sMemberStorageInfo = 0;
static hx::StaticInfo Scene_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*cpp::ArrayBase*/ ,(void *) &Scene_obj::scenelist,HX_HCSTRING("scenelist","\xaa","\x8b","\x59","\xb3")},
	{hx::fsInt,(void *) &Scene_obj::currentscene,HX_HCSTRING("currentscene","\x73","\x4e","\xb0","\x2c")},
	{hx::fsBool,(void *) &Scene_obj::hasseperaterenderfunction,HX_HCSTRING("hasseperaterenderfunction","\xef","\xe6","\x40","\x1d")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void Scene_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Scene_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Scene_obj::scenelist,"scenelist");
	HX_MARK_MEMBER_NAME(Scene_obj::currentscene,"currentscene");
	HX_MARK_MEMBER_NAME(Scene_obj::hasseperaterenderfunction,"hasseperaterenderfunction");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Scene_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Scene_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Scene_obj::scenelist,"scenelist");
	HX_VISIT_MEMBER_NAME(Scene_obj::currentscene,"currentscene");
	HX_VISIT_MEMBER_NAME(Scene_obj::hasseperaterenderfunction,"hasseperaterenderfunction");
};

#endif

hx::Class Scene_obj::__mClass;

static ::String Scene_obj_sStaticFields[] = {
	HX_HCSTRING("init","\x10","\x3b","\xbb","\x45"),
	HX_HCSTRING("restart","\xcf","\xc7","\xa5","\x6a"),
	HX_HCSTRING("checkforrenderfunction","\x6f","\x07","\xfe","\x32"),
	HX_HCSTRING("update","\x09","\x86","\x05","\x87"),
	HX_HCSTRING("render","\x56","\x6b","\x29","\x05"),
	HX_HCSTRING("callscenemethod","\x4f","\x61","\xe7","\x09"),
	HX_HCSTRING("findscene","\x73","\x9a","\x9b","\xd4"),
	HX_HCSTRING("change","\x70","\x91","\x72","\xb7"),
	HX_HCSTRING("get","\x96","\x80","\x4e","\x00"),
	HX_HCSTRING("getcurrentsceneclass","\x8f","\x5f","\xc7","\x74"),
	HX_HCSTRING("scenelist","\xaa","\x8b","\x59","\xb3"),
	HX_HCSTRING("currentscene","\x73","\x4e","\xb0","\x2c"),
	HX_HCSTRING("hasseperaterenderfunction","\xef","\xe6","\x40","\x1d"),
	::String(null())
};

void Scene_obj::__register()
{
	hx::Object *dummy = new Scene_obj;
	Scene_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("haxegon.Scene","\x1e","\xbb","\x02","\x80");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Scene_obj::__GetStatic;
	__mClass->mSetStaticField = &Scene_obj::__SetStatic;
	__mClass->mMarkFunc = Scene_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Scene_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< Scene_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Scene_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Scene_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Scene_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace haxegon
