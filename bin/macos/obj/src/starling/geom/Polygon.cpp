// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_openfl__Vector_AbstractVector
#include <openfl/_Vector/AbstractVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_FloatVector
#include <openfl/_Vector/FloatVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_IVector
#include <openfl/_Vector/IVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_IntVector
#include <openfl/_Vector/IntVector.h>
#endif
#ifndef INCLUDED_openfl_errors_ArgumentError
#include <openfl/errors/ArgumentError.h>
#endif
#ifndef INCLUDED_openfl_errors_Error
#include <openfl/errors/Error.h>
#endif
#ifndef INCLUDED_openfl_errors_RangeError
#include <openfl/errors/RangeError.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_starling_geom_Ellipse
#include <starling/geom/Ellipse.h>
#endif
#ifndef INCLUDED_starling_geom_ImmutablePolygon
#include <starling/geom/ImmutablePolygon.h>
#endif
#ifndef INCLUDED_starling_geom_Polygon
#include <starling/geom/Polygon.h>
#endif
#ifndef INCLUDED_starling_geom_Rectangle
#include <starling/geom/Rectangle.h>
#endif
#ifndef INCLUDED_starling_rendering_IndexData
#include <starling/rendering/IndexData.h>
#endif
#ifndef INCLUDED_starling_rendering_VertexData
#include <starling/rendering/VertexData.h>
#endif
#ifndef INCLUDED_starling_utils_MathUtil
#include <starling/utils/MathUtil.h>
#endif
#ifndef INCLUDED_starling_utils_Pool
#include <starling/utils/Pool.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_57_new,"starling.geom.Polygon","new",0x3b5e6a00,"starling.geom.Polygon.new","starling/geom/Polygon.hx",57,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_64_clone,"starling.geom.Polygon","clone",0x4e7f54fd,"starling.geom.Polygon.clone","starling/geom/Polygon.hx",64,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_77_reverse,"starling.geom.Polygon","reverse",0x11e422c2,"starling.geom.Polygon.reverse","starling/geom/Polygon.hx",77,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_99_addVertices,"starling.geom.Polygon","addVertices",0x0f1f30da,"starling.geom.Polygon.addVertices","starling/geom/Polygon.hx",99,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_126_setVertex,"starling.geom.Polygon","setVertex",0x70dce246,"starling.geom.Polygon.setVertex","starling/geom/Polygon.hx",126,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_137_getVertex,"starling.geom.Polygon","getVertex",0x8d8bf63a,"starling.geom.Polygon.getVertex","starling/geom/Polygon.hx",137,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_148_contains,"starling.geom.Polygon","contains",0x407fdc7f,"starling.geom.Polygon.contains","starling/geom/Polygon.hx",148,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_174_containsPoint,"starling.geom.Polygon","containsPoint",0x37929b51,"starling.geom.Polygon.containsPoint","starling/geom/Polygon.hx",174,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_184_triangulate,"starling.geom.Polygon","triangulate",0x5d4a9ecc,"starling.geom.Polygon.triangulate","starling/geom/Polygon.hx",184,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_271_copyToVertexData,"starling.geom.Polygon","copyToVertexData",0x6b7936be,"starling.geom.Polygon.copyToVertexData","starling/geom/Polygon.hx",271,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_284_toString,"starling.geom.Polygon","toString",0x4c73530c,"starling.geom.Polygon.toString","starling/geom/Polygon.hx",284,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_363_get_isSimple,"starling.geom.Polygon","get_isSimple",0x89e78625,"starling.geom.Polygon.get_isSimple","starling/geom/Polygon.hx",363,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_398_get_isConvex,"starling.geom.Polygon","get_isConvex",0x9946f95a,"starling.geom.Polygon.get_isConvex","starling/geom/Polygon.hx",398,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_423_get_area,"starling.geom.Polygon","get_area",0xd433c976,"starling.geom.Polygon.get_area","starling/geom/Polygon.hx",423,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_447_get_numVertices,"starling.geom.Polygon","get_numVertices",0x5c685196,"starling.geom.Polygon.get_numVertices","starling/geom/Polygon.hx",447,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_451_set_numVertices,"starling.geom.Polygon","set_numVertices",0x5833cea2,"starling.geom.Polygon.set_numVertices","starling/geom/Polygon.hx",451,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_466_get_numTriangles,"starling.geom.Polygon","get_numTriangles",0x952e086e,"starling.geom.Polygon.get_numTriangles","starling/geom/Polygon.hx",466,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_306_createEllipse,"starling.geom.Polygon","createEllipse",0x986ffae2,"starling.geom.Polygon.createEllipse","starling/geom/Polygon.hx",306,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_312_createCircle,"starling.geom.Polygon","createCircle",0x3c47e48c,"starling.geom.Polygon.createCircle","starling/geom/Polygon.hx",312,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_319_createRectangle,"starling.geom.Polygon","createRectangle",0xffcc1733,"starling.geom.Polygon.createRectangle","starling/geom/Polygon.hx",319,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_330_isConvexTriangle,"starling.geom.Polygon","isConvexTriangle",0x08434939,"starling.geom.Polygon.isConvexTriangle","starling/geom/Polygon.hx",330,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_336_areVectorsIntersecting,"starling.geom.Polygon","areVectorsIntersecting",0x6857483f,"starling.geom.Polygon.areVectorsIntersecting","starling/geom/Polygon.hx",336,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_36_boot,"starling.geom.Polygon","boot",0xaf575692,"starling.geom.Polygon.boot","starling/geom/Polygon.hx",36,0x416f69d0)
namespace starling{
namespace geom{

void Polygon_obj::__construct(::cpp::VirtualArray vertices){
            	HX_GC_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_57_new)
HXLINE(  58)		int length = null();
HXDLIN(  58)		bool fixed = null();
HXDLIN(  58)		this->_hx___coords =  ::openfl::_Vector::AbstractVector_obj::__alloc( HX_CTX , ::openfl::_Vector::FloatVector_obj::__alloc( HX_CTX ,length,fixed,null()),null());
HXLINE(  59)		this->addVertices(vertices);
            	}

Dynamic Polygon_obj::__CreateEmpty() { return new Polygon_obj; }

void *Polygon_obj::_hx_vtable = 0;

Dynamic Polygon_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Polygon_obj > _hx_result = new Polygon_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool Polygon_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x481a82d6;
}

 ::starling::geom::Polygon Polygon_obj::clone(){
            	HX_GC_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_64_clone)
HXLINE(  65)		 ::starling::geom::Polygon clone =  ::starling::geom::Polygon_obj::__alloc( HX_CTX ,null());
HXLINE(  66)		int numCoords = ::openfl::_Vector::IVector_obj::get_length(this->_hx___coords->data);
HXLINE(  68)		{
HXLINE(  68)			int _g1 = (int)0;
HXDLIN(  68)			int _g = numCoords;
HXDLIN(  68)			while((_g1 < _g)){
HXLINE(  68)				_g1 = (_g1 + (int)1);
HXDLIN(  68)				int i = (_g1 - (int)1);
HXLINE(  69)				{
HXLINE(  69)					 ::openfl::_Vector::AbstractVector this1 = clone->_hx___coords;
HXDLIN(  69)					Float value = ( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,i)) );
HXDLIN(  69)					::openfl::_Vector::IVector_obj::set(this1->data,i,value);
            				}
            			}
            		}
HXLINE(  71)		return clone;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Polygon_obj,clone,return )

void Polygon_obj::reverse(){
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_77_reverse)
HXLINE(  78)		int numCoords = ::openfl::_Vector::IVector_obj::get_length(this->_hx___coords->data);
HXLINE(  79)		int numVertices = ::Std_obj::_hx_int(((Float)numCoords / (Float)(int)2));
HXLINE(  80)		Float tmp;
HXLINE(  82)		int i = (int)0;
HXLINE(  83)		while((i < numVertices)){
HXLINE(  85)			tmp = ( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,i)) );
HXLINE(  86)			{
HXLINE(  86)				 ::openfl::_Vector::AbstractVector this1 = this->_hx___coords;
HXDLIN(  86)				::Dynamic this2 = this->_hx___coords->data;
HXDLIN(  86)				Float value = ( (Float)(::openfl::_Vector::IVector_obj::get(this2,((numCoords - i) - (int)2))) );
HXDLIN(  86)				::openfl::_Vector::IVector_obj::set(this1->data,i,value);
            			}
HXLINE(  87)			{
HXLINE(  87)				::Dynamic this3 = this->_hx___coords->data;
HXDLIN(  87)				::openfl::_Vector::IVector_obj::set(this3,((numCoords - i) - (int)2),tmp);
            			}
HXLINE(  89)			::Dynamic this4 = this->_hx___coords->data;
HXDLIN(  89)			tmp = ( (Float)(::openfl::_Vector::IVector_obj::get(this4,(i + (int)1))) );
HXLINE(  90)			{
HXLINE(  90)				 ::openfl::_Vector::AbstractVector this5 = this->_hx___coords;
HXDLIN(  90)				::Dynamic this6 = this->_hx___coords->data;
HXDLIN(  90)				Float value1 = ( (Float)(::openfl::_Vector::IVector_obj::get(this6,((numCoords - i) - (int)1))) );
HXDLIN(  90)				::Dynamic this7 = this5->data;
HXDLIN(  90)				::openfl::_Vector::IVector_obj::set(this7,(i + (int)1),value1);
            			}
HXLINE(  91)			{
HXLINE(  91)				::Dynamic this8 = this->_hx___coords->data;
HXDLIN(  91)				::openfl::_Vector::IVector_obj::set(this8,((numCoords - i) - (int)1),tmp);
            			}
HXLINE(  92)			i = (i + (int)2);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Polygon_obj,reverse,(void))

void Polygon_obj::addVertices(::cpp::VirtualArray args){
            	HX_GC_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_99_addVertices)
HXLINE( 100)		int i;
HXLINE( 101)		int numArgs = args->get_length();
HXLINE( 102)		int numCoords = ::openfl::_Vector::IVector_obj::get_length(this->_hx___coords->data);
HXLINE( 104)		if ((numArgs > (int)0)) {
HXLINE( 106)			if (::Std_obj::is(args->__get((int)0),hx::ClassOf< ::openfl::geom::Point >())) {
HXLINE( 108)				int _g1 = (int)0;
HXDLIN( 108)				int _g = numArgs;
HXDLIN( 108)				while((_g1 < _g)){
HXLINE( 108)					_g1 = (_g1 + (int)1);
HXDLIN( 108)					int i1 = (_g1 - (int)1);
HXLINE( 110)					{
HXLINE( 110)						::Dynamic this1 = this->_hx___coords->data;
HXDLIN( 110)						::openfl::_Vector::IVector_obj::set(this1,(numCoords + (i1 * (int)2)),hx::TCast<  ::openfl::geom::Point >::cast(args->__get(i1))->x);
            					}
HXLINE( 111)					{
HXLINE( 111)						::Dynamic this2 = this->_hx___coords->data;
HXDLIN( 111)						::openfl::_Vector::IVector_obj::set(this2,((numCoords + (i1 * (int)2)) + (int)1),hx::TCast<  ::openfl::geom::Point >::cast(args->__get(i1))->y);
            					}
            				}
            			}
            			else {
HXLINE( 114)				if (::Std_obj::is(args->__get((int)0),hx::ClassOf< ::Float >())) {
HXLINE( 116)					int _g11 = (int)0;
HXDLIN( 116)					int _g2 = numArgs;
HXDLIN( 116)					while((_g11 < _g2)){
HXLINE( 116)						_g11 = (_g11 + (int)1);
HXDLIN( 116)						int i2 = (_g11 - (int)1);
HXLINE( 117)						{
HXLINE( 117)							::Dynamic this3 = this->_hx___coords->data;
HXDLIN( 117)							::openfl::_Vector::IVector_obj::set(this3,(numCoords + i2),( (Float)(args->__get(i2)) ));
            						}
            					}
            				}
            				else {
HXLINE( 119)					HX_STACK_DO_THROW( ::openfl::errors::ArgumentError_obj::__alloc( HX_CTX ,(HX_("Invalid type: ",09,b6,ae,24) + ::Type_obj::getClassName(::Type_obj::getClass(args->__get((int)0))))));
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Polygon_obj,addVertices,(void))

void Polygon_obj::setVertex(int index,Float x,Float y){
            	HX_GC_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_126_setVertex)
HXDLIN( 126)		bool _hx_tmp;
HXDLIN( 126)		if ((index >= (int)0)) {
HXDLIN( 126)			_hx_tmp = (index <= this->get_numVertices());
            		}
            		else {
HXDLIN( 126)			_hx_tmp = false;
            		}
HXDLIN( 126)		if (_hx_tmp) {
HXLINE( 128)			{
HXLINE( 128)				::Dynamic this1 = this->_hx___coords->data;
HXDLIN( 128)				::openfl::_Vector::IVector_obj::set(this1,(index * (int)2),x);
            			}
HXLINE( 129)			{
HXLINE( 129)				::Dynamic this2 = this->_hx___coords->data;
HXDLIN( 129)				::openfl::_Vector::IVector_obj::set(this2,((index * (int)2) + (int)1),y);
            			}
            		}
            		else {
HXLINE( 131)			HX_STACK_DO_THROW( ::openfl::errors::RangeError_obj::__alloc( HX_CTX ,(HX_("Invalid index: ",ef,ab,37,dc) + index)));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(Polygon_obj,setVertex,(void))

 ::openfl::geom::Point Polygon_obj::getVertex(int index, ::openfl::geom::Point out){
            	HX_GC_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_137_getVertex)
HXDLIN( 137)		bool _hx_tmp;
HXDLIN( 137)		if ((index >= (int)0)) {
HXDLIN( 137)			_hx_tmp = (index < this->get_numVertices());
            		}
            		else {
HXDLIN( 137)			_hx_tmp = false;
            		}
HXDLIN( 137)		if (_hx_tmp) {
HXLINE( 139)			if (hx::IsNull( out )) {
HXLINE( 139)				out =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,null(),null());
            			}
            			else {
HXLINE( 139)				out = out;
            			}
HXLINE( 140)			::Dynamic this1 = this->_hx___coords->data;
HXDLIN( 140)			Float _hx_tmp1 = ( (Float)(::openfl::_Vector::IVector_obj::get(this1,(index * (int)2))) );
HXDLIN( 140)			::Dynamic this2 = this->_hx___coords->data;
HXDLIN( 140)			out->setTo(_hx_tmp1,( (Float)(::openfl::_Vector::IVector_obj::get(this2,((index * (int)2) + (int)1))) ));
HXLINE( 141)			return out;
            		}
            		else {
HXLINE( 143)			HX_STACK_DO_THROW( ::openfl::errors::RangeError_obj::__alloc( HX_CTX ,(HX_("Invalid index: ",ef,ab,37,dc) + index)));
            		}
HXLINE( 137)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC2(Polygon_obj,getVertex,return )

bool Polygon_obj::contains(Float x,Float y){
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_148_contains)
HXLINE( 152)		int i;
HXDLIN( 152)		int j = (this->get_numVertices() - (int)1);
HXLINE( 153)		int oddNodes = (int)0;
HXLINE( 155)		{
HXLINE( 155)			int _g1 = (int)0;
HXDLIN( 155)			int _g = this->get_numVertices();
HXDLIN( 155)			while((_g1 < _g)){
HXLINE( 155)				_g1 = (_g1 + (int)1);
HXDLIN( 155)				int i1 = (_g1 - (int)1);
HXLINE( 157)				::Dynamic this1 = this->_hx___coords->data;
HXDLIN( 157)				Float ix = ( (Float)(::openfl::_Vector::IVector_obj::get(this1,(i1 * (int)2))) );
HXLINE( 158)				::Dynamic this2 = this->_hx___coords->data;
HXDLIN( 158)				Float iy = ( (Float)(::openfl::_Vector::IVector_obj::get(this2,((i1 * (int)2) + (int)1))) );
HXLINE( 159)				::Dynamic this3 = this->_hx___coords->data;
HXDLIN( 159)				Float jx = ( (Float)(::openfl::_Vector::IVector_obj::get(this3,(j * (int)2))) );
HXLINE( 160)				::Dynamic this4 = this->_hx___coords->data;
HXDLIN( 160)				Float jy = ( (Float)(::openfl::_Vector::IVector_obj::get(this4,((j * (int)2) + (int)1))) );
HXLINE( 162)				bool _hx_tmp;
HXDLIN( 162)				bool _hx_tmp1;
HXDLIN( 162)				bool _hx_tmp2;
HXDLIN( 162)				if ((iy < y)) {
HXLINE( 162)					_hx_tmp2 = (jy >= y);
            				}
            				else {
HXLINE( 162)					_hx_tmp2 = false;
            				}
HXDLIN( 162)				if (!(_hx_tmp2)) {
HXLINE( 162)					if ((jy < y)) {
HXLINE( 162)						_hx_tmp1 = (iy >= y);
            					}
            					else {
HXLINE( 162)						_hx_tmp1 = false;
            					}
            				}
            				else {
HXLINE( 162)					_hx_tmp1 = true;
            				}
HXDLIN( 162)				if (_hx_tmp1) {
HXLINE( 162)					if (!((ix <= x))) {
HXLINE( 162)						_hx_tmp = (jx <= x);
            					}
            					else {
HXLINE( 162)						_hx_tmp = true;
            					}
            				}
            				else {
HXLINE( 162)					_hx_tmp = false;
            				}
HXDLIN( 162)				if (_hx_tmp) {
HXLINE( 163)					int oddNodes1;
HXDLIN( 163)					if (((ix + (((Float)(y - iy) / (Float)(jy - iy)) * (jx - ix))) < x)) {
HXLINE( 163)						oddNodes1 = (int)1;
            					}
            					else {
HXLINE( 163)						oddNodes1 = (int)0;
            					}
HXDLIN( 163)					oddNodes = ((int)oddNodes ^ (int)oddNodes1);
            				}
HXLINE( 165)				j = i1;
            			}
            		}
HXLINE( 168)		return (oddNodes != (int)0);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Polygon_obj,contains,return )

bool Polygon_obj::containsPoint( ::openfl::geom::Point point){
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_174_containsPoint)
HXDLIN( 174)		return this->contains(point->x,point->y);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Polygon_obj,containsPoint,return )

 ::starling::rendering::IndexData Polygon_obj::triangulate( ::starling::rendering::IndexData indexData,hx::Null< int >  __o_offset){
int offset = __o_offset.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_184_triangulate)
HXLINE( 191)		int numVertices = this->get_numVertices();
HXLINE( 192)		int numTriangles = this->get_numTriangles();
HXLINE( 193)		int i;
HXDLIN( 193)		int restIndexPos;
HXDLIN( 193)		int numRestIndices;
HXLINE( 195)		if (hx::IsNull( indexData )) {
HXLINE( 195)			indexData =  ::starling::rendering::IndexData_obj::__alloc( HX_CTX ,(numTriangles * (int)3));
            		}
HXLINE( 196)		if ((numTriangles == (int)0)) {
HXLINE( 196)			return indexData;
            		}
HXLINE( 198)		::openfl::_Vector::IVector_obj::set_length(::starling::geom::Polygon_obj::sRestIndices->data,numVertices);
HXLINE( 199)		{
HXLINE( 199)			int _g1 = (int)0;
HXDLIN( 199)			int _g = numVertices;
HXDLIN( 199)			while((_g1 < _g)){
HXLINE( 199)				_g1 = (_g1 + (int)1);
HXDLIN( 199)				int i1 = (_g1 - (int)1);
HXDLIN( 199)				::openfl::_Vector::IVector_obj::set(::starling::geom::Polygon_obj::sRestIndices->data,i1,i1);
            			}
            		}
HXLINE( 201)		restIndexPos = (int)0;
HXLINE( 202)		numRestIndices = numVertices;
HXLINE( 204)		 ::openfl::geom::Point a = ::starling::utils::Pool_obj::getPoint(null(),null());
HXLINE( 205)		 ::openfl::geom::Point b = ::starling::utils::Pool_obj::getPoint(null(),null());
HXLINE( 206)		 ::openfl::geom::Point c = ::starling::utils::Pool_obj::getPoint(null(),null());
HXLINE( 207)		 ::openfl::geom::Point p = ::starling::utils::Pool_obj::getPoint(null(),null());
HXLINE( 209)		while((numRestIndices > (int)3)){
HXLINE( 216)			int otherIndex;
HXLINE( 217)			bool earFound = false;
HXLINE( 218)			::Dynamic this1 = ::starling::geom::Polygon_obj::sRestIndices->data;
HXDLIN( 218)			int i0 = ( (int)(::openfl::_Vector::IVector_obj::get(this1,hx::Mod(restIndexPos,numRestIndices))) );
HXLINE( 219)			::Dynamic this2 = ::starling::geom::Polygon_obj::sRestIndices->data;
HXDLIN( 219)			int i11 = ( (int)(::openfl::_Vector::IVector_obj::get(this2,hx::Mod((restIndexPos + (int)1),numRestIndices))) );
HXLINE( 220)			::Dynamic this3 = ::starling::geom::Polygon_obj::sRestIndices->data;
HXDLIN( 220)			int i2 = ( (int)(::openfl::_Vector::IVector_obj::get(this3,hx::Mod((restIndexPos + (int)2),numRestIndices))) );
HXLINE( 222)			Float _hx_tmp = ( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,((int)2 * i0))) );
HXDLIN( 222)			a->setTo(_hx_tmp,( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,(((int)2 * i0) + (int)1))) ));
HXLINE( 223)			Float _hx_tmp1 = ( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,((int)2 * i11))) );
HXDLIN( 223)			b->setTo(_hx_tmp1,( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,(((int)2 * i11) + (int)1))) ));
HXLINE( 224)			Float _hx_tmp2 = ( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,((int)2 * i2))) );
HXDLIN( 224)			c->setTo(_hx_tmp2,( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,(((int)2 * i2) + (int)1))) ));
HXLINE( 226)			Float bx = b->x;
HXDLIN( 226)			Float by = b->y;
HXDLIN( 226)			if (((((a->y - by) * (c->x - bx)) + ((bx - a->x) * (c->y - by))) >= (int)0)) {
HXLINE( 228)				earFound = true;
HXLINE( 229)				{
HXLINE( 229)					int _g11 = (int)3;
HXDLIN( 229)					int _g2 = numRestIndices;
HXDLIN( 229)					while((_g11 < _g2)){
HXLINE( 229)						_g11 = (_g11 + (int)1);
HXDLIN( 229)						int i3 = (_g11 - (int)1);
HXLINE( 231)						::Dynamic this4 = ::starling::geom::Polygon_obj::sRestIndices->data;
HXDLIN( 231)						otherIndex = ( (int)(::openfl::_Vector::IVector_obj::get(this4,hx::Mod((restIndexPos + i3),numRestIndices))) );
HXLINE( 232)						Float _hx_tmp3 = ( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,((int)2 * otherIndex))) );
HXDLIN( 232)						p->setTo(_hx_tmp3,( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,(((int)2 * otherIndex) + (int)1))) ));
HXLINE( 234)						if (::starling::utils::MathUtil_obj::isPointInTriangle(p,a,b,c)) {
HXLINE( 236)							earFound = false;
HXLINE( 237)							goto _hx_goto_15;
            						}
            					}
            					_hx_goto_15:;
            				}
            			}
HXLINE( 242)			if (earFound) {
HXLINE( 244)				indexData->addTriangle((i0 + offset),(i11 + offset),(i2 + offset));
HXLINE( 245)				{
HXLINE( 245)					::Dynamic this5 = ::starling::geom::Polygon_obj::sRestIndices->data;
HXDLIN( 245)					::openfl::_Vector::IVector_obj::removeAt(this5,hx::Mod((restIndexPos + (int)1),numRestIndices));
            				}
HXLINE( 247)				numRestIndices = (numRestIndices - (int)1);
HXLINE( 248)				restIndexPos = (int)0;
            			}
            			else {
HXLINE( 252)				restIndexPos = (restIndexPos + (int)1);
HXLINE( 253)				if ((restIndexPos == numRestIndices)) {
HXLINE( 253)					goto _hx_goto_14;
            				}
            			}
            		}
            		_hx_goto_14:;
HXLINE( 257)		::starling::utils::Pool_obj::putPoint(a);
HXLINE( 258)		::starling::utils::Pool_obj::putPoint(b);
HXLINE( 259)		::starling::utils::Pool_obj::putPoint(c);
HXLINE( 260)		::starling::utils::Pool_obj::putPoint(p);
HXLINE( 262)		int _hx_tmp4 = (( (int)(::openfl::_Vector::IVector_obj::get(::starling::geom::Polygon_obj::sRestIndices->data,(int)0)) ) + offset);
HXLINE( 263)		int _hx_tmp5 = (( (int)(::openfl::_Vector::IVector_obj::get(::starling::geom::Polygon_obj::sRestIndices->data,(int)1)) ) + offset);
HXLINE( 262)		indexData->addTriangle(_hx_tmp4,_hx_tmp5,(( (int)(::openfl::_Vector::IVector_obj::get(::starling::geom::Polygon_obj::sRestIndices->data,(int)2)) ) + offset));
HXLINE( 265)		return indexData;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Polygon_obj,triangulate,return )

void Polygon_obj::copyToVertexData( ::starling::rendering::VertexData target,hx::Null< int >  __o_targetVertexID,::String __o_attrName){
int targetVertexID = __o_targetVertexID.Default(0);
::String attrName = __o_attrName.Default(HX_HCSTRING("position","\xa9","\xa0","\xfa","\xca"));
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_271_copyToVertexData)
HXLINE( 272)		int numVertices = this->get_numVertices();
HXLINE( 273)		int requiredTargetLength = (targetVertexID + numVertices);
HXLINE( 275)		if ((target->get_numVertices() < requiredTargetLength)) {
HXLINE( 276)			target->set_numVertices(requiredTargetLength);
            		}
HXLINE( 278)		{
HXLINE( 278)			int _g1 = (int)0;
HXDLIN( 278)			int _g = numVertices;
HXDLIN( 278)			while((_g1 < _g)){
HXLINE( 278)				_g1 = (_g1 + (int)1);
HXDLIN( 278)				int i = (_g1 - (int)1);
HXLINE( 279)				::Dynamic this1 = this->_hx___coords->data;
HXDLIN( 279)				Float _hx_tmp = ( (Float)(::openfl::_Vector::IVector_obj::get(this1,(i * (int)2))) );
HXDLIN( 279)				::Dynamic this2 = this->_hx___coords->data;
HXDLIN( 279)				target->setPoint((targetVertexID + i),attrName,_hx_tmp,( (Float)(::openfl::_Vector::IVector_obj::get(this2,((i * (int)2) + (int)1))) ));
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(Polygon_obj,copyToVertexData,(void))

::String Polygon_obj::toString(){
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_284_toString)
HXLINE( 285)		::String result = HX_("[Polygon",5f,bb,d0,34);
HXLINE( 286)		int numPoints = this->get_numVertices();
HXLINE( 288)		if ((numPoints > (int)0)) {
HXLINE( 288)			result = (result + HX_("\n",0a,00,00,00));
            		}
HXLINE( 290)		{
HXLINE( 290)			int _g1 = (int)0;
HXDLIN( 290)			int _g = numPoints;
HXDLIN( 290)			while((_g1 < _g)){
HXLINE( 290)				_g1 = (_g1 + (int)1);
HXDLIN( 290)				int i = (_g1 - (int)1);
HXLINE( 293)				::Dynamic this1 = this->_hx___coords->data;
HXLINE( 292)				::String result1 = ((((((HX_("  [Vertex ",21,f1,53,07) + i) + HX_(": ",a6,32,00,00)) + HX_("x=",c5,68,00,00)) + ::starling::utils::MathUtil_obj::toFixed(( (Float)(::openfl::_Vector::IVector_obj::get(this1,(i * (int)2))) ),(int)1)) + HX_(", ",74,26,00,00)) + HX_("y=",a4,69,00,00));
HXLINE( 294)				::Dynamic this2 = this->_hx___coords->data;
HXLINE( 292)				::String result2 = ((result1 + ::starling::utils::MathUtil_obj::toFixed(( (Float)(::openfl::_Vector::IVector_obj::get(this2,((i * (int)2) + (int)1))) ),(int)1)) + HX_("]",5d,00,00,00));
HXLINE( 295)				::String result3;
HXDLIN( 295)				if ((i == (numPoints - (int)1))) {
HXLINE( 295)					result3 = HX_("\n",0a,00,00,00);
            				}
            				else {
HXLINE( 295)					result3 = HX_(",\n",5e,26,00,00);
            				}
HXLINE( 292)				result = (result + (result2 + result3));
            			}
            		}
HXLINE( 298)		return (result + HX_("]",5d,00,00,00));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Polygon_obj,toString,return )

bool Polygon_obj::get_isSimple(){
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_363_get_isSimple)
HXLINE( 364)		int numCoords = ::openfl::_Vector::IVector_obj::get_length(this->_hx___coords->data);
HXLINE( 365)		if ((numCoords <= (int)6)) {
HXLINE( 365)			return true;
            		}
HXLINE( 367)		int i = (int)0;
HXLINE( 368)		while((i < numCoords)){
HXLINE( 370)			Float ax = ( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,i)) );
HXLINE( 371)			::Dynamic this1 = this->_hx___coords->data;
HXDLIN( 371)			Float ay = ( (Float)(::openfl::_Vector::IVector_obj::get(this1,(i + (int)1))) );
HXLINE( 372)			::Dynamic this2 = this->_hx___coords->data;
HXDLIN( 372)			Float bx = ( (Float)(::openfl::_Vector::IVector_obj::get(this2,hx::Mod((i + (int)2),numCoords))) );
HXLINE( 373)			::Dynamic this3 = this->_hx___coords->data;
HXDLIN( 373)			Float by = ( (Float)(::openfl::_Vector::IVector_obj::get(this3,hx::Mod((i + (int)3),numCoords))) );
HXLINE( 374)			Float endJ = ((i + numCoords) - (int)2);
HXLINE( 376)			int j = (i + (int)4);
HXLINE( 377)			while((j < endJ)){
HXLINE( 379)				::Dynamic this4 = this->_hx___coords->data;
HXDLIN( 379)				Float cx = ( (Float)(::openfl::_Vector::IVector_obj::get(this4,hx::Mod(j,numCoords))) );
HXLINE( 380)				::Dynamic this5 = this->_hx___coords->data;
HXDLIN( 380)				Float cy = ( (Float)(::openfl::_Vector::IVector_obj::get(this5,hx::Mod((j + (int)1),numCoords))) );
HXLINE( 381)				::Dynamic this6 = this->_hx___coords->data;
HXDLIN( 381)				Float dx = ( (Float)(::openfl::_Vector::IVector_obj::get(this6,hx::Mod((j + (int)2),numCoords))) );
HXLINE( 382)				::Dynamic this7 = this->_hx___coords->data;
HXDLIN( 382)				Float dy = ( (Float)(::openfl::_Vector::IVector_obj::get(this7,hx::Mod((j + (int)3),numCoords))) );
HXLINE( 384)				if (::starling::geom::Polygon_obj::areVectorsIntersecting(ax,ay,bx,by,cx,cy,dx,dy)) {
HXLINE( 385)					return false;
            				}
HXLINE( 386)				j = (j + (int)2);
            			}
HXLINE( 388)			i = (i + (int)2);
            		}
HXLINE( 391)		return true;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Polygon_obj,get_isSimple,return )

bool Polygon_obj::get_isConvex(){
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_398_get_isConvex)
HXLINE( 399)		int numCoords = ::openfl::_Vector::IVector_obj::get_length(this->_hx___coords->data);
HXLINE( 401)		if ((numCoords < (int)6)) {
HXLINE( 401)			return true;
            		}
            		else {
HXLINE( 404)			int i = (int)0;
HXLINE( 405)			while((i < numCoords)){
HXLINE( 407)				Float ax = ( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,i)) );
HXDLIN( 407)				::Dynamic this1 = this->_hx___coords->data;
HXDLIN( 407)				Float ay = ( (Float)(::openfl::_Vector::IVector_obj::get(this1,(i + (int)1))) );
HXLINE( 408)				::Dynamic this2 = this->_hx___coords->data;
HXLINE( 407)				Float bx = ( (Float)(::openfl::_Vector::IVector_obj::get(this2,hx::Mod((i + (int)2),numCoords))) );
HXLINE( 408)				::Dynamic this3 = this->_hx___coords->data;
HXLINE( 407)				Float by = ( (Float)(::openfl::_Vector::IVector_obj::get(this3,hx::Mod((i + (int)3),numCoords))) );
HXLINE( 409)				::Dynamic this4 = this->_hx___coords->data;
HXLINE( 407)				Float cx = ( (Float)(::openfl::_Vector::IVector_obj::get(this4,hx::Mod((i + (int)4),numCoords))) );
HXLINE( 409)				::Dynamic this5 = this->_hx___coords->data;
HXLINE( 407)				if (!(((((ay - by) * (cx - bx)) + ((bx - ax) * (( (Float)(::openfl::_Vector::IVector_obj::get(this5,hx::Mod((i + (int)5),numCoords))) ) - by))) >= (int)0))) {
HXLINE( 411)					return false;
            				}
HXLINE( 413)				i = (i + (int)2);
            			}
            		}
HXLINE( 417)		return true;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Polygon_obj,get_isConvex,return )

Float Polygon_obj::get_area(){
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_423_get_area)
HXLINE( 424)		Float area = (int)0;
HXLINE( 425)		int numCoords = ::openfl::_Vector::IVector_obj::get_length(this->_hx___coords->data);
HXLINE( 427)		if ((numCoords >= (int)6)) {
HXLINE( 429)			int i = (int)0;
HXLINE( 430)			while((i < numCoords)){
HXLINE( 432)				Float area1 = ( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,i)) );
HXDLIN( 432)				::Dynamic this1 = this->_hx___coords->data;
HXDLIN( 432)				area = (area + (area1 * ( (Float)(::openfl::_Vector::IVector_obj::get(this1,hx::Mod((i + (int)3),numCoords))) )));
HXLINE( 433)				::Dynamic this2 = this->_hx___coords->data;
HXDLIN( 433)				Float area2 = ( (Float)(::openfl::_Vector::IVector_obj::get(this2,(i + (int)1))) );
HXDLIN( 433)				::Dynamic this3 = this->_hx___coords->data;
HXDLIN( 433)				area = (area - (area2 * ( (Float)(::openfl::_Vector::IVector_obj::get(this3,hx::Mod((i + (int)2),numCoords))) )));
HXLINE( 434)				i = (i + (int)2);
            			}
            		}
HXLINE( 438)		return ((Float)area / (Float)((Float)2.0));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Polygon_obj,get_area,return )

int Polygon_obj::get_numVertices(){
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_447_get_numVertices)
HXDLIN( 447)		return ::Std_obj::_hx_int(((Float)::openfl::_Vector::IVector_obj::get_length(this->_hx___coords->data) / (Float)(int)2));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Polygon_obj,get_numVertices,return )

int Polygon_obj::set_numVertices(int value){
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_451_set_numVertices)
HXLINE( 452)		int oldLength = this->get_numVertices();
HXLINE( 453)		{
HXLINE( 453)			::Dynamic this1 = this->_hx___coords->data;
HXDLIN( 453)			::openfl::_Vector::IVector_obj::set_length(this1,(value * (int)2));
            		}
HXLINE( 455)		if ((oldLength < value)) {
HXLINE( 457)			int _g1 = oldLength;
HXDLIN( 457)			int _g = value;
HXDLIN( 457)			while((_g1 < _g)){
HXLINE( 457)				_g1 = (_g1 + (int)1);
HXDLIN( 457)				int i = (_g1 - (int)1);
HXLINE( 458)				{
HXLINE( 458)					 ::openfl::_Vector::AbstractVector this2 = this->_hx___coords;
HXDLIN( 458)					::Dynamic this3 = this->_hx___coords->data;
HXDLIN( 458)					Float value1 = ( (Float)(::openfl::_Vector::IVector_obj::set(this3,((i * (int)2) + (int)1),((Float)0.0))) );
HXDLIN( 458)					::Dynamic this4 = this2->data;
HXDLIN( 458)					::openfl::_Vector::IVector_obj::set(this4,(i * (int)2),value1);
            				}
            			}
            		}
HXLINE( 460)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Polygon_obj,set_numVertices,return )

int Polygon_obj::get_numTriangles(){
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_466_get_numTriangles)
HXLINE( 467)		int numVertices = this->get_numVertices();
HXLINE( 468)		if ((numVertices >= (int)3)) {
HXLINE( 468)			return (numVertices - (int)2);
            		}
            		else {
HXLINE( 468)			return (int)0;
            		}
HXDLIN( 468)		return (int)0;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Polygon_obj,get_numTriangles,return )

 ::openfl::_Vector::AbstractVector Polygon_obj::sRestIndices;

 ::starling::geom::Polygon Polygon_obj::createEllipse(Float x,Float y,Float radiusX,Float radiusY,hx::Null< int >  __o_numSides){
int numSides = __o_numSides.Default(-1);
            	HX_GC_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_306_createEllipse)
HXDLIN( 306)		return  ::starling::geom::Ellipse_obj::__alloc( HX_CTX ,x,y,radiusX,radiusY,numSides);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Polygon_obj,createEllipse,return )

 ::starling::geom::Polygon Polygon_obj::createCircle(Float x,Float y,Float radius,hx::Null< int >  __o_numSides){
int numSides = __o_numSides.Default(-1);
            	HX_GC_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_312_createCircle)
HXDLIN( 312)		return  ::starling::geom::Ellipse_obj::__alloc( HX_CTX ,x,y,radius,radius,numSides);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Polygon_obj,createCircle,return )

 ::starling::geom::Polygon Polygon_obj::createRectangle(Float x,Float y,Float width,Float height){
            	HX_GC_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_319_createRectangle)
HXDLIN( 319)		return  ::starling::geom::Rectangle_obj::__alloc( HX_CTX ,x,y,width,height);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Polygon_obj,createRectangle,return )

bool Polygon_obj::isConvexTriangle(Float ax,Float ay,Float bx,Float by,Float cx,Float cy){
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_330_isConvexTriangle)
HXDLIN( 330)		return ((((ay - by) * (cx - bx)) + ((bx - ax) * (cy - by))) >= (int)0);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Polygon_obj,isConvexTriangle,return )

bool Polygon_obj::areVectorsIntersecting(Float ax,Float ay,Float bx,Float by,Float cx,Float cy,Float dx,Float dy){
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_336_areVectorsIntersecting)
HXLINE( 337)		bool _hx_tmp;
HXDLIN( 337)		bool _hx_tmp1;
HXDLIN( 337)		if ((ax == bx)) {
HXLINE( 337)			_hx_tmp1 = (ay == by);
            		}
            		else {
HXLINE( 337)			_hx_tmp1 = false;
            		}
HXDLIN( 337)		if (!(_hx_tmp1)) {
HXLINE( 337)			if ((cx == dx)) {
HXLINE( 337)				_hx_tmp = (cy == dy);
            			}
            			else {
HXLINE( 337)				_hx_tmp = false;
            			}
            		}
            		else {
HXLINE( 337)			_hx_tmp = true;
            		}
HXDLIN( 337)		if (_hx_tmp) {
HXLINE( 337)			return false;
            		}
HXLINE( 339)		Float abx = (bx - ax);
HXLINE( 340)		Float aby = (by - ay);
HXLINE( 341)		Float cdx = (dx - cx);
HXLINE( 342)		Float cdy = (dy - cy);
HXLINE( 343)		Float tDen = ((cdy * abx) - (cdx * aby));
HXLINE( 345)		if ((tDen == ((Float)0.0))) {
HXLINE( 345)			return false;
            		}
HXLINE( 347)		Float t = ((Float)((aby * (cx - ax)) - (abx * (cy - ay))) / (Float)tDen);
HXLINE( 349)		bool _hx_tmp2;
HXDLIN( 349)		if (!((t < (int)0))) {
HXLINE( 349)			_hx_tmp2 = (t > (int)1);
            		}
            		else {
HXLINE( 349)			_hx_tmp2 = true;
            		}
HXDLIN( 349)		if (_hx_tmp2) {
HXLINE( 349)			return false;
            		}
HXLINE( 351)		Float s;
HXDLIN( 351)		if ((aby != ((Float)0.0))) {
HXLINE( 351)			s = ((Float)((cy - ay) + (t * cdy)) / (Float)aby);
            		}
            		else {
HXLINE( 351)			s = ((Float)((cx - ax) + (t * cdx)) / (Float)abx);
            		}
HXLINE( 354)		if ((s >= ((Float)0.0))) {
HXLINE( 354)			return (s <= ((Float)1.0));
            		}
            		else {
HXLINE( 354)			return false;
            		}
HXDLIN( 354)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(Polygon_obj,areVectorsIntersecting,return )


hx::ObjectPtr< Polygon_obj > Polygon_obj::__new(::cpp::VirtualArray vertices) {
	hx::ObjectPtr< Polygon_obj > __this = new Polygon_obj();
	__this->__construct(vertices);
	return __this;
}

hx::ObjectPtr< Polygon_obj > Polygon_obj::__alloc(hx::Ctx *_hx_ctx,::cpp::VirtualArray vertices) {
	Polygon_obj *__this = (Polygon_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Polygon_obj), true, "starling.geom.Polygon"));
	*(void **)__this = Polygon_obj::_hx_vtable;
	__this->__construct(vertices);
	return __this;
}

Polygon_obj::Polygon_obj()
{
}

void Polygon_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Polygon);
	HX_MARK_MEMBER_NAME(_hx___coords,"__coords");
	HX_MARK_END_CLASS();
}

void Polygon_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(_hx___coords,"__coords");
}

hx::Val Polygon_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"area") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_area() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"clone") ) { return hx::Val( clone_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"reverse") ) { return hx::Val( reverse_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"__coords") ) { return hx::Val( _hx___coords ); }
		if (HX_FIELD_EQ(inName,"contains") ) { return hx::Val( contains_dyn() ); }
		if (HX_FIELD_EQ(inName,"toString") ) { return hx::Val( toString_dyn() ); }
		if (HX_FIELD_EQ(inName,"isSimple") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_isSimple() ); }
		if (HX_FIELD_EQ(inName,"isConvex") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_isConvex() ); }
		if (HX_FIELD_EQ(inName,"get_area") ) { return hx::Val( get_area_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"setVertex") ) { return hx::Val( setVertex_dyn() ); }
		if (HX_FIELD_EQ(inName,"getVertex") ) { return hx::Val( getVertex_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"addVertices") ) { return hx::Val( addVertices_dyn() ); }
		if (HX_FIELD_EQ(inName,"triangulate") ) { return hx::Val( triangulate_dyn() ); }
		if (HX_FIELD_EQ(inName,"numVertices") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_numVertices() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"get_isSimple") ) { return hx::Val( get_isSimple_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_isConvex") ) { return hx::Val( get_isConvex_dyn() ); }
		if (HX_FIELD_EQ(inName,"numTriangles") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_numTriangles() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"containsPoint") ) { return hx::Val( containsPoint_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"get_numVertices") ) { return hx::Val( get_numVertices_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_numVertices") ) { return hx::Val( set_numVertices_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"copyToVertexData") ) { return hx::Val( copyToVertexData_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_numTriangles") ) { return hx::Val( get_numTriangles_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Polygon_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 12:
		if (HX_FIELD_EQ(inName,"sRestIndices") ) { outValue = ( sRestIndices ); return true; }
		if (HX_FIELD_EQ(inName,"createCircle") ) { outValue = createCircle_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"createEllipse") ) { outValue = createEllipse_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"createRectangle") ) { outValue = createRectangle_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"isConvexTriangle") ) { outValue = isConvexTriangle_dyn(); return true; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"areVectorsIntersecting") ) { outValue = areVectorsIntersecting_dyn(); return true; }
	}
	return false;
}

hx::Val Polygon_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"__coords") ) { _hx___coords=inValue.Cast<  ::openfl::_Vector::AbstractVector >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"numVertices") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_numVertices(inValue.Cast< int >()) ); }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool Polygon_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 12:
		if (HX_FIELD_EQ(inName,"sRestIndices") ) { sRestIndices=ioValue.Cast<  ::openfl::_Vector::AbstractVector >(); return true; }
	}
	return false;
}

void Polygon_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("__coords","\x3e","\x0f","\xb4","\x70"));
	outFields->push(HX_HCSTRING("isSimple","\xbc","\x9f","\xe8","\x10"));
	outFields->push(HX_HCSTRING("isConvex","\xf1","\x12","\x48","\x20"));
	outFields->push(HX_HCSTRING("area","\x8d","\x8b","\x74","\x40"));
	outFields->push(HX_HCSTRING("numVertices","\x5f","\x10","\x2c","\x56"));
	outFields->push(HX_HCSTRING("numTriangles","\x85","\x39","\xb1","\x26"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Polygon_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::openfl::_Vector::AbstractVector*/ ,(int)offsetof(Polygon_obj,_hx___coords),HX_HCSTRING("__coords","\x3e","\x0f","\xb4","\x70")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo Polygon_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::openfl::_Vector::AbstractVector*/ ,(void *) &Polygon_obj::sRestIndices,HX_HCSTRING("sRestIndices","\xc0","\x34","\x91","\x0b")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String Polygon_obj_sMemberFields[] = {
	HX_HCSTRING("__coords","\x3e","\x0f","\xb4","\x70"),
	HX_HCSTRING("clone","\x5d","\x13","\x63","\x48"),
	HX_HCSTRING("reverse","\x22","\x39","\xfc","\x1a"),
	HX_HCSTRING("addVertices","\x3a","\xf7","\x71","\x9b"),
	HX_HCSTRING("setVertex","\xa6","\x50","\xef","\x00"),
	HX_HCSTRING("getVertex","\x9a","\x64","\x9e","\x1d"),
	HX_HCSTRING("contains","\x1f","\x5a","\x7b","\x2c"),
	HX_HCSTRING("containsPoint","\xb1","\xb9","\xeb","\x92"),
	HX_HCSTRING("triangulate","\x2c","\x65","\x9d","\xe9"),
	HX_HCSTRING("copyToVertexData","\x5e","\x54","\x9b","\x01"),
	HX_HCSTRING("toString","\xac","\xd0","\x6e","\x38"),
	HX_HCSTRING("get_isSimple","\xc5","\x53","\x02","\xc6"),
	HX_HCSTRING("get_isConvex","\xfa","\xc6","\x61","\xd5"),
	HX_HCSTRING("get_area","\x16","\x47","\x2f","\xc0"),
	HX_HCSTRING("get_numVertices","\xf6","\xc7","\x0d","\x17"),
	HX_HCSTRING("set_numVertices","\x02","\x45","\xd9","\x12"),
	HX_HCSTRING("get_numTriangles","\x0e","\x26","\x50","\x2b"),
	::String(null()) };

static void Polygon_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Polygon_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Polygon_obj::sRestIndices,"sRestIndices");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Polygon_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Polygon_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Polygon_obj::sRestIndices,"sRestIndices");
};

#endif

hx::Class Polygon_obj::__mClass;

static ::String Polygon_obj_sStaticFields[] = {
	HX_HCSTRING("sRestIndices","\xc0","\x34","\x91","\x0b"),
	HX_HCSTRING("createEllipse","\x42","\x19","\xc9","\xf3"),
	HX_HCSTRING("createCircle","\x2c","\xb2","\x62","\x78"),
	HX_HCSTRING("createRectangle","\x93","\x8d","\x71","\xba"),
	HX_HCSTRING("isConvexTriangle","\xd9","\x66","\x65","\x9e"),
	HX_HCSTRING("areVectorsIntersecting","\xdf","\x5d","\xd7","\x2f"),
	::String(null())
};

void Polygon_obj::__register()
{
	hx::Object *dummy = new Polygon_obj;
	Polygon_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("starling.geom.Polygon","\x0e","\xaa","\xe9","\x45");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Polygon_obj::__GetStatic;
	__mClass->mSetStaticField = &Polygon_obj::__SetStatic;
	__mClass->mMarkFunc = Polygon_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Polygon_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Polygon_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Polygon_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Polygon_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Polygon_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Polygon_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Polygon_obj::__boot()
{
{
            		HX_BEGIN_LOCAL_FUNC_S0(hx::LocalFunc,_hx_Closure_0) HXARGC(0)
            		 ::Dynamic _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_36_boot)
HXDLIN(  36)			int length = null();
HXDLIN(  36)			bool fixed = null();
HXDLIN(  36)			return  ::openfl::_Vector::AbstractVector_obj::__alloc( HX_CTX , ::openfl::_Vector::IntVector_obj::__alloc( HX_CTX ,length,fixed,null()),null());
            		}
            		HX_END_LOCAL_FUNC0(return)

            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_36_boot)
HXDLIN(  36)		sRestIndices =  ::Dynamic(new _hx_Closure_0())();
            	}
}

} // end namespace starling
} // end namespace geom
